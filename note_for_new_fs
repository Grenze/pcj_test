1.for nvm, every param type of File or Path should:
    a.first convert to File.getCanonicalPath()[unique for ObjectDirectory]
    b.second convert to String to identify file or directory[global id]

2.getName() and getParentFile() supported by java.io.File

3.for every directory, it should also keep its sub's local name(String) in its HashSet<String>
    to index them

4.no idea about the actual type before you get the file or directory out of ObjectDirectory
    so File and Directory the same class with boolean isFile and isDirectory, isEmpty



5.ObjectDirectory.put(id1, class) and put(id2, class) then id1 and id2 refer to the same class
    if ObjectDirectory.remove(id1, class), then ObjectDirectory.get(id2, class) can get it

6.ObjectDirectory.put(id1, class1) and put(id1, class2) then class1 garbage collected

7.ObjectDirectory.get(id, class)==null

8.rename operation of a directory or file can be done like this(its parent/ itself/ its child):

    String oldParentDirectoryString = oldFileName.getParentFile().toString();
    ObjectDirectory.get(oldParentDirectoryString).childHashSet().remove(oldFileName.getName());
    //String newParentDirectoryString = newFileName.getParentFile().toString();//exist?
    nvmMkdirs(newFileName.getParentFile());//whatever create it or prove it
    String newParentDirectoryString = newFileName.getParentFile().toString();
    ObjectDirectory.get(newParentDirectoryString).childHashSet().add(newFileName.getName());

    String oldFileNameString = oldFileName.toString();
    String newFileNameString = newFileName.toString();
    ObjectDirectory.put(newFileNameString, ObjectDirectory.remove(oldFileNameString));
    //to travel every layer underneath
    for (String key: globalID.keySet()){
        if(key.startWith(oldFileNameString)){
            ObjectDirectory.put(newFileNameString+key.substring(oldFileNameString.length()), ObjectDirectory.remove(key));
        }
    }

9.delete operation of a directory or file:

    String oldParentDirectoryString = oldFileName.getParentFile().toString();
    ObjectDirectory.get(oldParentDirectoryString).childHashSet().remove(oldFileName.getName());

    String oldFileNameString = oldFileName.toString();
    ObjectDirectory.remove(oldFileNameString);

    for (String key: globalID.keySet()){
        if(key.startWith(oldFileNameString)){
            ObjectDirectory.remove(key);
        }
    }

10.nvmMkdirs(File file, isFile, is Directory)
        file.exist,return
        File parentFile = new File(file).getParentFile();
        if(ObjectDirectory.get(parentFile.toString())==null){
            nvmMkdirs(parentFile, false, true);
        }
        nvmMkFilDir(File, isFile, isDirectory);
        ObjectDirectory.get(parentFile.toString(), nvmFilDir.class()).childHashSet().add(file.getName());

    nvmMkFilDir(File f, isFile, isDirectory)
        nvmFilDir nFD = new nvmFilDir(isFile, isDirectory);
        ObjectDirectory.put(f.toString(), nvmFilDir);

11.two space:
    FilDir name space PersistentHashMap<String, FilDir>
    FilDirIndex name space PersistentHashMap<String, PersistentHashMap<String, boolean>>

12.copy method new FilDir constructor(FilDirOut) this.param=FilDirOut.param

13.add this method to copyRecursively() as set to iterate
static Set<String> listWithFilter(FileFilter filter, String fromDirectory){
    Set<String> temp = new Set<String>;
    for (String key: globalID.keySet()){
        if(key.startWith(fromDirectory) && filter.accept(new File(key))){
            temp.add(key);
        }
    }
    return temp;
}

14.






